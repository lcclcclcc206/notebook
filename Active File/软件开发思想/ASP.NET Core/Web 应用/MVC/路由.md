ASP.NET Core 控制器使用路由[中间件](https://learn.microsoft.com/zh-cn/aspnet/core/fundamentals/middleware/?view=aspnetcore-7.0)来匹配传入请求的 URL 并将它们映射到[操作](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#action)。 路由模板：

- 在启动时 `Program.cs` 或在属性中定义。
- 描述 URL 路径如何与[操作](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#action)相匹配。
- 用于生成链接的 URL。 生成的链接通常在响应中返回。

操作既支持[传统路由](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#cr6)，也支持[属性路由](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#ar6)。 通过在控制器或[操作](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#action)上放置路由可实现属性路由。 有关详细信息，请参阅[混合路由](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#routing-mixed-ref-label)。

此文档：

- 说明了 MVC 与路由之间的交互：
  - 典型的 MVC 应用如何使用路由功能。
  - 涵盖以下两种路由：
    - [传统路由](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#cr6)，通常与控制器和视图一起使用。
    - 与 API 一起使用REST*的属性路由*。 如果主要对 API 的REST路由感兴趣，请跳转到 [API 的属性路由REST](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#ar6)部分。
  - 有关高级路由的详细信息，请参阅[路由](https://learn.microsoft.com/zh-cn/aspnet/core/fundamentals/routing?view=aspnetcore-7.0)。
- 指称为终结点路由的默认路由系统。 出于兼容性目的，可以将控制器与先前版本的路由一起使用。 有关说明，请参阅 [2.2-3.0 迁移指南](https://learn.microsoft.com/zh-cn/aspnet/core/migration/22-to-30?view=aspnetcore-7.0)。

## 设置传统路由

ASP.NET Core MVC 模板生成类似于以下内容的[传统路由](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#crd6)代码：

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllersWithViews();

var app = builder.Build();

if (!app.Environment.IsDevelopment())
{
    app.UseExceptionHandler("/Home/Error");
    app.UseHsts();
}

app.UseHttpsRedirection();
app.UseStaticFiles();

app.UseRouting();

app.UseAuthorization();

app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");

app.Run();
```

[MapControllerRoute](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.controllerendpointroutebuilderextensions.mapcontrollerroute) 用于创建单个路由。 单个路由命名为 `default` 路由。 大多数具有控制器和视图的应用都使用类似 `default` 路由的路由模板。 REST API 应使用 [属性路由](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#ar6)。

```csharp
app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");
```

路由模板 `"{controller=Home}/{action=Index}/{id?}"`：

- 匹配 URL 路径，例如 `/Products/Details/5`

- 通过标记路径来提取路由值 `{ controller = Products, action = Details, id = 5 }`。 如果应用有一个名为 `ProductsController` 的控制器和一个 `Details` 操作，则提取路由值会导致匹配：

  ```csharp
  public class ProductsController : Controller
  {
      public IActionResult Details(int id)
      {
          return ControllerContext.MyDisplayRouteInfo(id);
      }
  }
  ```

  [MyDisplayRouteInfo](https://github.com/Rick-Anderson/RouteInfo/blob/master/Microsoft.Docs.Samples.RouteInfo/ControllerContextExtensions.cs) 由 [Rick.Docs.Samples.RouteInfo](https://www.nuget.org/packages/Rick.Docs.Samples.RouteInfo) NuGet 包提供，会显示路由信息。

- `/Products/Details/5` 模型绑定 `id = 5` 的值，以将 `id` 参数设置为 `5`。 有关更多详细信息，请参阅[模型绑定](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/models/model-binding?view=aspnetcore-7.0)。
- `{controller=Home}` 将 `Home` 定义为默认 `controller`。
- `{action=Index}` 将 `Index` 定义为默认 `action`。
- `{id?}` 中的 `?` 字符将 `id` 定义为可选。
  - 默认路由参数和可选路由参数不必包含在 URL 路径中进行匹配。 有关路由模板语法的详细说明，请参阅[路由模板参考](https://learn.microsoft.com/zh-cn/aspnet/core/fundamentals/routing?view=aspnetcore-7.0#route-template-reference)。
- 匹配 URL 路径 `/`。
- 生成路由值 `{ controller = Home, action = Index }`。

`controller` 和 `action` 的值使用默认值。 `id` 不会生成值，因为 URL 路径中没有相应的段。 `/` 仅在存在 `HomeController` 和 `Index` 操作时匹配：

```csharp
public class HomeController : Controller
{
    public IActionResult Index() { ... }
}
```

使用前面的控制器定义和路由模板，为以下 URL 路径运行 `HomeController.Index` 操作：

- `/Home/Index/17`
- `/Home/Index`
- `/Home`
- `/`

URL 路径 `/` 使用路由模板默认 `Home` 控制器和 `Index` 操作。 URL 路径 `/Home` 使用路由模板默认 `Index` 操作。

简便方法 [MapDefaultControllerRoute](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.controllerendpointroutebuilderextensions.mapdefaultcontrollerroute)：

```csharp
app.MapDefaultControllerRoute();
```

替代：

```csharp
app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");
```

> 使用 [UseRouting](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.endpointroutingapplicationbuilderextensions.userouting) 和 [UseEndpoints](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.endpointroutingapplicationbuilderextensions.useendpoints) 中间件配置路由。 要使用控制器，请执行以下操作：
>
> - 调用 [MapControllers](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.controllerendpointroutebuilderextensions.mapcontrollers) 以映射[属性路由](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#ar6)控制器。
> - 调用 [MapControllerRoute](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.controllerendpointroutebuilderextensions.mapcontrollerroute) 或 [MapAreaControllerRoute](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.controllerendpointroutebuilderextensions.mapareacontrollerroute) 以映射[传统路由](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#cr6)控制器和[属性路由](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#ar6)控制器。
>
> 应用通常不需要调用 `UseRouting` 或 `UseEndpoints`。 [WebApplicationBuilder](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.webapplicationbuilder) 配置中间件管道，该管道使用 `UseRouting` 和 `UseEndpoints` 包装在 `Program.cs` 中添加的中间件。 有关详细信息，请参阅 [ASP.NET Core 中的路由](https://learn.microsoft.com/zh-cn/aspnet/core/fundamentals/routing?view=aspnetcore-7.0)。

## 传统路由

传统路由与控制器和视图一起使用。 `default` 路由：

```csharp
app.MapControllerRoute(
    name: "default",
    pattern: "{controller=Home}/{action=Index}/{id?}");
```

以上是传统路由的示例。 之所以称为传统路由，是因为它为 URL 路径建立了一个约定：

- 第一个路径段 `{controller=Home}` 映射到控制器名称。
- 第二段 `{action=Index}` 映射到[操作](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#action)名称。
- 第三段 `{id?}` 用于可选 `id`。 `{id?}` 中的 `?` 使其成为可选。 `id` 用于映射到模型实体。

使用此 `default` 路由，URL 路径：

- `/Products/List` 映射到 `ProductsController.List` 操作。
- `/Blog/Article/17` 映射到 `BlogController.Article`，并且模型通常将 `id` 参数绑定到 17。

此映射：

- 仅基于控制器和[操作](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#action)名称。
- 不基于命名空间、源文件位置或方法参数。

使用默认路由进行传统路由可以创建应用，而无需为每个操作提出新的 URL 模式。 对于具有 [CRUD](https://wikipedia.org/wiki/Create,_read,_update_and_delete) 样式操作的应用，跨控制器的 URL 保持一致：

- 有助于简化代码。
- 使 UI 更具可预测性。

大多数应用应选择基本的描述性路由方案，让 URL 有可读性和意义。 默认传统路由 `{controller=Home}/{action=Index}/{id?}`：

- 支持基本的描述性路由方案。
- 是基于 UI 的应用的有用起点。
- 是许多 Web UI 应用所需的唯一路由模板。 对于较大的 Web UI 应用，通常只需要使用[区域](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#areas)的另一个路由。

[MapControllerRoute](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.controllerendpointroutebuilderextensions.mapcontrollerroute) 和 [MapAreaRoute](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.mvcarearoutebuilderextensions.maparearoute)：

- 根据调用的顺序自动为其终结点分配一个顺序值。

ASP.NET Core 中的终结点路由：

- 没有路由的概念。
- 不为扩展性的执行提供顺序保证，所有终结点都会立即处理。

启用[日志记录](https://learn.microsoft.com/zh-cn/aspnet/core/fundamentals/logging/?view=aspnetcore-7.0)以查看内置路由实现（如 [Route](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.routing.route)）如何匹配请求。

[属性路由](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#ar6)将在本文档后面介绍。

### 多个传统路由

可以通过添加对和的[MapAreaControllerRoute](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.controllerendpointroutebuilderextensions.mapareacontrollerroute)更多调用[MapControllerRoute](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.controllerendpointroutebuilderextensions.mapcontrollerroute)来配置多个[常规路由](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#cr6)。 这样做允许定义多个约定，或添加专用于特定[操作](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#action)的传统路由，例如：

```csharp
app.MapControllerRoute(name: "blog",
                pattern: "blog/{*article}",
                defaults: new { controller = "Blog", action = "Article" });
app.MapControllerRoute(name: "default",
               pattern: "{controller=Home}/{action=Index}/{id?}");
```

`blog`前面的代码中的路由是**一个专用的传统路由**。 之所以称为专用传统路由是因为：

- 它使用[传统路由](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#cr6)。
- 它专用于特定[操作](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#action)。

因为 `controller` 和 `action` 不会以参数形式出现在路由模板 `"blog/{*article}"` 中：

- 它们只能具有默认值 `{ controller = "Blog", action = "Article" }`。
- 此路由始终映射到操作 `BlogController.Article`。

`/Blog`、`/Blog/Article` 和 `/Blog/{any-string}` 是唯一与博客路由匹配的 URL 路径。

上面的示例：

- `blog` 路由比 `default` 路由具有更高的匹配优先级，因为它最先添加。
- 是 [Slug](https://developer.mozilla.org/docs/Glossary/Slug) 样式路由的示例，通常将文章名称作为 URL 的一部分。

### 传统路由顺序

常规路由仅匹配应用定义的操作和控制器的组合。 这是为了简化传统路由重叠的情况。 使用 [MapControllerRoute](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.controllerendpointroutebuilderextensions.mapcontrollerroute)、[MapDefaultControllerRoute](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.controllerendpointroutebuilderextensions.mapdefaultcontrollerroute) 和 [MapAreaControllerRoute](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.controllerendpointroutebuilderextensions.mapareacontrollerroute) 添加路由会根据调用它们的顺序自动为其终结点分配一个顺序值。 来自较早出现的路由的匹配具有更高的优先级。 传统路由依赖于顺序。 一般情况下，具有区域的路由应放在路由表中靠前的位置，因为它们比没有区域的路由更具体。 具有 catch-all 路由参数的[专用传统路由](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#dcr)（例如 `{*article}`）会使某个路由变得[太贪婪](https://learn.microsoft.com/zh-cn/aspnet/core/fundamentals/routing?view=aspnetcore-7.0#greedy)，也就是说，它会匹配你想要使用其他路由来匹配的 URL。 将贪婪路由放在路由表中靠后的位置可解决此问题。	

### 解决不明确的操作

如果两个终结点通过路由匹配，则路由必须执行下列操作之一：

- 选择最佳的候选项。
- 引发异常。

例如：

```csharp
public class Products33Controller : Controller
{
    public IActionResult Edit(int id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }

    [HttpPost]
    public IActionResult Edit(int id, Product product)
    {
        return ControllerContext.MyDisplayRouteInfo(id, product.name);
    }
}
```

前面的控制器定义了两个匹配的操作：

- URL 路径 `/Products33/Edit/17`
- 路由数据 `{ controller = Products33, action = Edit, id = 17 }`。

这是 MVC 控制器的典型模式：

- `Edit(int)` 显示用于编辑产品的表单。
- `Edit(int, Product)` 处理已发布的表单。

要解析正确的路由，请执行以下操作：

- 当请求为 HTTP `POST` 时，选择 `Edit(int, Product)`。
- 当 [HTTP 谓词](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#verb)为其他任何内容时，选择 `Edit(int)`。 `Edit(int)` 通常通过 `GET` 调用。

向路由提供 [HttpPostAttribute](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.httppostattribute) 和 `[HttpPost]`，以便它根据请求的 HTTP 方法进行选择。 `HttpPostAttribute` 使 `Edit(int, Product)` 比 `Edit(int)` 更匹配。

了解 `HttpPostAttribute` 等属性的作用很重要。 为其他 [HTTP 谓词](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#verb)定义了类似的属性。 在[传统路由](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#cr6)中，当操作属于显示表单、提交表单工作流时，通常使用相同的操作名称。 例如，请参阅[检查两个 Edit 操作方法](https://learn.microsoft.com/zh-cn/aspnet/core/tutorials/first-mvc-app/controller-methods-views?view=aspnetcore-7.0#get-post)。

如果路由无法选择最佳候选项，则会引发 [AmbiguousMatchException](https://learn.microsoft.com/zh-cn/dotnet/api/system.reflection.ambiguousmatchexception)，列出多个匹配的终结点。

### 传统路由名称

以下示例中的 `"blog"` 和 `"default"` 字符串都是传统路由名称：

```csharp
app.MapControllerRoute(name: "blog",
                pattern: "blog/{*article}",
                defaults: new { controller = "Blog", action = "Article" });
app.MapControllerRoute(name: "default",
               pattern: "{controller=Home}/{action=Index}/{id?}");
```

路由名称为路由指定逻辑名称。 命名路由可用于生成 URL。 当路由顺序可能使 URL 生成变得复杂时，使用命名路由可以简化 URL 创建。 路由名称在应用程序范围内必须唯一。

路由名称：

- 对 URL 匹配或请求处理没有影响。
- 仅用于生成 URL。

路由名称概念在路由中表示为 [IEndpointNameMetadata](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.routing.iendpointnamemetadata)。 术语“路由名称”和“终结点名称”：

- 可互换。
- 文档和代码中使用哪一个取决于所描述的 API。

## API 的属性路由REST

REST API 应使用属性路由将应用的功能建模为一组资源，其中操作由 [HTTP 谓词](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#verb)表示。

属性路由使用一组属性将操作直接映射到路由模板。 以下代码是 REST API 的典型代码，在下一个示例中使用：

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllers();

var app = builder.Build();

app.UseHttpsRedirection();

app.UseAuthorization();

app.MapControllers();

app.Run();
```

在前面的代码中， [MapControllers](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.controllerendpointroutebuilderextensions.mapcontrollers) 调用它来映射属性路由控制器。

在以下示例中：

- `HomeController` 匹配一组类似于默认传统路由 `{controller=Home}/{action=Index}/{id?}` 匹配的 URL。

```csharp
public class HomeController : Controller
{
    [Route("")]
    [Route("Home")]
    [Route("Home/Index")]
    [Route("Home/Index/{id?}")]
    public IActionResult Index(int? id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }

    [Route("Home/About")]
    [Route("Home/About/{id?}")]
    public IActionResult About(int? id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }
}
```

将针对任意 URL 路径 `/`、`/Home`、`/Home/Index` 或 `/Home/Index/3` 执行 `HomeController.Index` 操作。

此示例重点介绍属性路由与[传统路由](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#cr6)之间的主要编程差异。 属性路由需要更多输入才能指定路由。 传统默认路由会更简洁地处理路由。 但是，属性路由允许并需要精确控制应用于每项[操作](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#action)的路由模板。

对于属性路由，控制器和操作名称在操作匹配中不起作用，除非使用[标记替换](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#routing-token-replacement-templates-ref-label)。 以下示例匹配与上一个示例相同的 URL：

```csharp
public class MyDemoController : Controller
{
    [Route("")]
    [Route("Home")]
    [Route("Home/Index")]
    [Route("Home/Index/{id?}")]
    public IActionResult MyIndex(int? id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }

    [Route("Home/About")]
    [Route("Home/About/{id?}")]
    public IActionResult MyAbout(int? id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }
}
```

以下代码对 `action` 和 `controller` 使用标记替换：

```csharp
public class HomeController : Controller
{
    [Route("")]
    [Route("Home")]
    [Route("[controller]/[action]")]
    public IActionResult Index()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }

    [Route("[controller]/[action]")]
    public IActionResult About()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }
}
```

以下代码将 `[Route("[controller]/[action]")]` 应用于控制器：制

```csharp
[Route("[controller]/[action]")]
public class HomeController : Controller
{
    [Route("~/")]
    [Route("/Home")]
    [Route("~/Home/Index")]
    public IActionResult Index()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }

    public IActionResult About()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }
}
```

在前面的代码中，`Index` 方法模板必须将 `/` 或 `~/` 预置到路由模板。 应用于操作的以 `/` 或 `~/` 开头的路由模板不与应用于控制器的路由模板合并。

有关路由模板选择的信息，请参阅[路由模板优先级](https://learn.microsoft.com/zh-cn/aspnet/core/fundamentals/routing?view=aspnetcore-7.0#rtp)。

## 保留的路由名称

以下关键字是使用控制器或 Razor Pages 时保留的路由参数名称：

- `action`
- `area`
- `controller`
- `handler`
- `page`

一个常见错误是使用 `page` 作为属性路由的路由参数。 这样做会导致与 URL 生成不一致和令人困惑的行为。

```csharp
public class MyDemo2Controller : Controller
{
    [Route("/articles/{page}")]
    public IActionResult ListArticles(int page)
    {
        return ControllerContext.MyDisplayRouteInfo(page);
    }
}
```

URL 生成使用特殊参数名称来确定 URL 生成操作是引用 Razor 页面还是控制器。

- 在 Razor 视图或 Razor 页面的上下文中保留以下关键字：
- `page`
- `using`
- `namespace`
- `inject`
- `section`
- `inherits`
- `model`
- `addTagHelper`
- `removeTagHelper`

不应将这些关键字用于链接生成、模型绑定参数或上层属性。

## HTTP 谓词模板

ASP.NET Core 具有以下 HTTP 谓词模板：

- [[HttpGet\]](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.httpgetattribute)
- [[HttpPost\]](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.httppostattribute)
- [[HttpPut\]](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.httpputattribute)
- [[HttpDelete\]](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.httpdeleteattribute)
- [[HttpHead\]](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.httpheadattribute)
- [[HttpPatch\]](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.httppatchattribute)

### 路由模板

ASP.NET Core 具有以下路由模板：

- 所有 [HTTP 谓词模板](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#verb6)都是路由模板。
- [[Route\]](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.routeattribute)

### 使用 Http 谓词属性的属性路由

考虑以下控制器：

```csharp
[Route("api/[controller]")]
[ApiController]
public class Test2Controller : ControllerBase
{
    [HttpGet]   // GET /api/test2
    public IActionResult ListProducts()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }

    [HttpGet("{id}")]   // GET /api/test2/xyz
    public IActionResult GetProduct(string id)
    {
       return ControllerContext.MyDisplayRouteInfo(id);
    }

    [HttpGet("int/{id:int}")] // GET /api/test2/int/3
    public IActionResult GetIntProduct(int id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }

    [HttpGet("int2/{id}")]  // GET /api/test2/int2/3
    public IActionResult GetInt2Product(int id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }
}
```

在上述代码中：

- 每个操作都包含 `[HttpGet]` 属性，该属性仅将匹配限制为 HTTP GET 请求。

- `GetProduct` 操作包含 `"{id}"` 模板，因此 `id` 被附加到控制器上的 `"api/[controller]"` 模板中。 方法模板为 `"api/[controller]/"{id}""`。 因此，此操作仅匹配 `/api/test2/xyz`、`/api/test2/123`、`/api/test2/{any string}` 等形式的 GET 请求。

  ```csharp
  [HttpGet("{id}")]   // GET /api/test2/xyz
  public IActionResult GetProduct(string id)
  {
     return ControllerContext.MyDisplayRouteInfo(id);
  }
  ```

- `GetIntProduct` 操作包含 `"int/{id:int}")` 模板。 模板的 `:int` 部分将 `id` 路由值限制为可以转换为整数的字符串。 对 `/api/test2/int/abc` 的 GET 请求：

  - 与此操作不匹配。
  - 返回 [404 Not Found](https://developer.mozilla.org/docs/Web/HTTP/Status/404) 错误。

  ```cs
  [HttpGet("int/{id:int}")] // GET /api/test2/int/3
  public IActionResult GetIntProduct(int id)
  {
      return ControllerContext.MyDisplayRouteInfo(id);
  }
  ```

- `GetInt2Product` 操作在模板中包含 `{id}`，但不将 `id` 限制为可以转换为整数的值。 对 `/api/test2/int2/abc` 的 GET 请求：

  - 与此路由匹配。
  - 模型绑定无法将 `abc` 转换为整数。 该方法的 `id` 参数是整数。
  - 返回 [400 Bad Request](https://developer.mozilla.org/docs/Web/HTTP/Status/400)，因为模型绑定未能将 `abc` 转换为整数。

  ```cs
  [HttpGet("int2/{id}")]  // GET /api/test2/int2/3
  public IActionResult GetInt2Product(int id)
  {
      return ControllerContext.MyDisplayRouteInfo(id);
  }
  ```

属性路由可以使用 [HttpMethodAttribute](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.routing.httpmethodattribute) 属性，例如 [HttpPostAttribute](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.httppostattribute)、[HttpPutAttribute](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.httpputattribute) 和 [HttpDeleteAttribute](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.httpdeleteattribute)。 所有 [HTTP 谓词](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#verb6)属性都接受路由模板。 以下示例展示了匹配同一路由模板的两个操作：

```csharp
[ApiController]
public class MyProductsController : ControllerBase
{
    [HttpGet("/products3")]
    public IActionResult ListProducts()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }

    [HttpPost("/products3")]
    public IActionResult CreateProduct(MyProduct myProduct)
    {
        return ControllerContext.MyDisplayRouteInfo(myProduct.Name);
    }
}
```

使用 URL 路径 `/products3`：

- 当 [HTTP 谓词](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#verb6) 为 `GET` 时，`MyProductsController.ListProducts` 操作运行。
- 当 [HTTP 谓词](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#verb6) 为 `POST` 时，`MyProductsController.CreateProduct` 操作运行。

生成 REST API 时，很少需要对操作方法使用 `[Route(...)]` ，因为该操作接受所有 HTTP 方法。 建议使用更具体的 [HTTP 谓词属性](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#verb6)来明确 API 所支持的操作。 API 的 REST 客户端应知道哪些路径和 HTTP 谓词映射到特定的逻辑操作。

REST API 应使用属性路由将应用的功能建模为一组资源，其中操作由 HTTP 谓词表示。 也就是说，对同一逻辑资源执行的许多操作（例如，GET 和 POST）都使用相同 URL。 属性路由提供了精心设计 API 的公共终结点布局所需的控制级别。

由于属性路由适用于特定操作，因此，使参数变成路由模板定义中的必需参数很简单。 在以下示例中，需要将 `id` 作为 URL 路径的一部分：

```csharp
[ApiController]
public class Products2ApiController : ControllerBase
{
    [HttpGet("/products2/{id}", Name = "Products_List")]
    public IActionResult GetProduct(int id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }
}
```

`Products2ApiController.GetProduct(int)` 操作：

- 使用类似 `/products2/3` 的 URL 路径运行
- 不使用 URL 路径 `/products2` 运行。

使用 [[Consumes\]](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.consumesattribute) 属性，操作可以限制支持的请求内容类型。 有关详细信息，请参阅[使用 Consumes 属性定义支持的请求内容类型](https://learn.microsoft.com/zh-cn/aspnet/core/web-api/?view=aspnetcore-7.0#consumes)。

请参阅[路由](https://learn.microsoft.com/zh-cn/aspnet/core/fundamentals/routing?view=aspnetcore-7.0)了解路由模板和相关选项的完整说明。

有关 `[ApiController]` 的详细信息，请参阅 [ApiController 属性](https://learn.microsoft.com/zh-cn/aspnet/core/web-api/?view=aspnetcore-7.0##apicontroller-attribute)。

## 路由名称

以下代码定义 `Products_List` 的路由名称：

```csharp
[ApiController]
public class Products2ApiController : ControllerBase
{
    [HttpGet("/products2/{id}", Name = "Products_List")]
    public IActionResult GetProduct(int id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }
}
```

可以使用路由名称基于特定路由生成 URL。 路由名称：

- 对路由的 URL 匹配行为没有影响。
- 仅用于生成 URL。

路由名称必须在应用程序范围内唯一。

前面的代码与传统默认路由相反，后者将 `id` 参数定义为可选 (`{id?}`)。 这种精确指定 API 的功能可带来一些好处，比如允许将 `/products` 和 `/products/5` 分派到不同的操作。

## 组合属性路由

若要使属性路由减少重复，可将控制器上的路由属性与各个操作上的路由属性合并。 控制器上定义的所有路由模板均作为操作上路由模板的前缀。 在控制器上放置路由属性会使控制器中的**所有**操作都使用属性路由。

```csharp
[ApiController]
[Route("products")]
public class ProductsApiController : ControllerBase
{
    [HttpGet]
    public IActionResult ListProducts()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }

    [HttpGet("{id}")]
    public IActionResult GetProduct(int id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }
}
```

在上面的示例中：

- URL 路径 `/products` 可以匹配 `ProductsApi.ListProducts`
- URL 路径 `/products/5` 可以匹配 `ProductsApi.GetProduct(int)`。

这两项操作仅匹配 HTTP `GET`，因为它们用 `[HttpGet]` 属性标记。

应用于操作的以 `/` 或 `~/` 开头的路由模板不与应用于控制器的路由模板合并。 以下示例匹配一组与默认路由类似的 URL 路径。

```csharp
[Route("Home")]
public class HomeController : Controller
{
    [Route("")]
    [Route("Index")]
    [Route("/")]
    public IActionResult Index()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }

    [Route("About")]
    public IActionResult About()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }
}
```

下表解释了前面代码中的 `[Route]` 属性：

| Attribute          | 与 `[Route("Home")]` 结合 | 定义路由模板   |
| :----------------- | :------------------------ | :------------- |
| `[Route("")]`      | 是                        | `"Home"`       |
| `[Route("Index")]` | 是                        | `"Home/Index"` |
| `[Route("/")]`     | **否**                    | `""`           |
| `[Route("About")]` | 是                        | `"Home/About"` |

### 属性路由顺序

https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#attribute-route-order

路由构建树并同时匹配所有终结点：

- 路由条目的行为就像以理想的顺序排列一样。
- 最具体的路由有机会在更通用的路由之前执行。

例如，`blog/search/{topic}` 之类的属性路由比 `blog/{*article}` 之类的属性路由更具体。 默认情况下，`blog/search/{topic}` 路由具有更高的优先级，因为它更具体。 使用[传统路由](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#cr6)时，开发人员负责按所需顺序放置路由。

属性路由可以使用 [Order](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.routeattribute.order#microsoft-aspnetcore-mvc-routeattribute-order) 属性配置顺序。 框架提供的所有[路由属性](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.routeattribute)都包括 `Order`。 路由按 `Order` 属性的升序进行处理。 默认顺序为 `0`。 使用 `Order = -1` 设置的路由在未设置顺序的路由之前运行。 使用 `Order = 1` 设置的路由在默认路由顺序之后运行。

避免依赖 `Order`。 如果应用的 URL 空间需要有显式顺序值才能正确进行路由，则同样可能使客户端混淆不清。 属性路由通常选择具有 URL 匹配的正确路由。 如果用于 URL 生成的默认顺序不起作用，使用路由名称作为替代项通常比应用 `Order` 属性更简单。

......

## 路由模板 [controller]、[action]、[area] 中的标记替换

为方便起见，属性路由支持标记替换，方法是将标记用方括号（`[`、`]`）括起来。 标记 `[action]`、`[area]` 和 `[controller]` 替换为定义了路由的操作中的操作名称值、区域名称值和控制器名称值：

```csharp
[Route("[controller]/[action]")]
public class Products0Controller : Controller
{
    [HttpGet]
    public IActionResult List()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }


    [HttpGet("{id}")]
    public IActionResult Edit(int id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }
}
```

属性路由还可以与继承结合使用。 与标记替换结合使用时尤为强大。 标记替换也适用于属性路由定义的路由名称。 `[Route("[controller]/[action]", Name="[controller]_[action]")]` 为每项操作生成唯一的路由名称：

```csharp
[ApiController]
[Route("api/[controller]/[action]", Name = "[controller]_[action]")]
public abstract class MyBase2Controller : ControllerBase
{
}

public class Products11Controller : MyBase2Controller
{
    [HttpGet]                      // /api/products11/list
    public IActionResult List()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }

    [HttpGet("{id}")]             //    /api/products11/edit/3
    public IActionResult Edit(int id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }
}
```

要匹配文本标记替换分隔符 `[` 或 `]`，可通过重复该字符（`[[` 或 `]]`）对其进行转义。

### 使用参数转换程序自定义标记替换

https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#use-a-parameter-transformer-to-customize-token-replacement

### 多个属性路由

https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#multiple-attribute-routes

### 指定属性路由的可选参数、默认值和约束

属性路由支持使用与传统路由相同的内联语法，来指定可选参数、默认值和约束。

```csharp
public class Products14Controller : Controller
{
    [HttpPost("product14/{id:int}")]
    public IActionResult ShowProduct(int id)
    {
        return ControllerContext.MyDisplayRouteInfo(id);
    }
}
```

在前面的代码中，`[HttpPost("product14/{id:int}")]` 应用路由约束。 `Products14Controller.ShowProduct` 操作仅与 `/product14/3` 等 URL 路径匹配。 路由模板部分 `{id:int}` 将该段限制为仅整数。

有关路由模板语法的详细说明，请参阅[路由模板参考](https://learn.microsoft.com/zh-cn/aspnet/core/fundamentals/routing?view=aspnetcore-7.0#route-template-reference)。

### 使用 IRouteTemplateProvider 的自定义路由属性

所有[路由属性](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#rt6)都实现 [IRouteTemplateProvider](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.routing.iroutetemplateprovider)。 ASP.NET Core 运行时：

- 应用启动时，在控制器类和操作方法上查找属性。
- 使用实现 `IRouteTemplateProvider` 的属性来构建初始路由集。

实现 `IRouteTemplateProvider` 以定义自定义路由属性。 每个 `IRouteTemplateProvider` 都允许定义一个包含自定义路由模板、顺序和名称的路由：



```csharp
public class MyApiControllerAttribute : Attribute, IRouteTemplateProvider
{
    public string Template => "api/[controller]";
    public int? Order => 2;
    public string Name { get; set; } = string.Empty;
}

[MyApiController]
[ApiController]
public class MyTestApiController : ControllerBase
{
    // GET /api/MyTestApi
    [HttpGet]
    public IActionResult Get()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }
}
```

前面的 `Get` 方法返回 `Order = 2, Template = api/MyTestApi`。

### 使用应用程序模型自定义属性路由

https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#use-application-model-to-customize-attribute-routes

应用程序模型：

- 是在启动时 `Program.cs`创建的对象模型。
- 包含 ASP.NET Core 用于在应用中路由和执行操作的所有元数据。

应用程序模型包含从路由属性收集的所有数据。 路由属性中的数据由 `IRouteTemplateProvider` 实现提供。 约定：

- 可以编写，以修改应用程序模型，自定义路由的行为方式。
- 在应用启动时读取。

## 混合路由：属性路由与传统路由

ASP.NET Core 应用可以混合使用传统路由和属性路由。 通常，对于为浏览器提供 HTML 页的控制器使用常规路由，以及为 API 提供服务 REST 的控制器的属性路由。

操作既支持传统路由，也支持属性路由。 通过在控制器或操作上放置路由可实现属性路由。 不能通过传统路由访问定义属性路由的操作，反之亦然。 控制器上的任何路由属性都会使控制器中的所有操作使用属性路由。

属性路由和传统路由使用相同的路由引擎。

## URL 生成和环境值

https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#url-generation-and-ambient-values

应用可以使用路由 URL 生成功能来生成指向操作的 URL 链接。 生成 URL 可消除[硬编码](https://wikipedia.org/wiki/Hard_coding) URL，使代码更稳定、更易维护。 本部分重点介绍 MVC 提供的 URL 生成功能，并且仅涵盖 URL 生成工作原理的基础知识。 有关 URL 生成的详细说明，请参阅[路由](https://learn.microsoft.com/zh-cn/aspnet/core/fundamentals/routing?view=aspnetcore-7.0)。

[IUrlHelper](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.iurlhelper) 接口用于生成 URL，是 MVC 与路由之间的基础结构的基础部分。 在控制器、视图和视图组件中，可通过 `Url` 属性获得 `IUrlHelper` 的实例。

在以下示例中，将通过 `Controller.Url` 属性使用 `IUrlHelper` 接口来生成指向另一项操作的 URL。

```csharp
public class UrlGenerationController : Controller
{
    public IActionResult Source()
    {
        // Generates /UrlGeneration/Destination
        var url = Url.Action("Destination");
        return ControllerContext.MyDisplayRouteInfo("", $" URL = {url}");
    }

    public IActionResult Destination()
    {
        return ControllerContext.MyDisplayRouteInfo();
    }
}
```

### 根据操作名称生成 URL

[Url.Action](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.iurlhelper.action)、[LinkGenerator.GetPathByAction](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.routing.controllerlinkgeneratorextensions.getpathbyaction) 和所有相关的重载都旨在通过指定控制器名称和操作名称来生成目标终结点。

使用 `Url.Action` 时，`controller` 和 `action` 的当前路由值由运行时提供：

- `controller` 和 `action` 的值是[环境值](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#ambient)和值的一部分。 `Url.Action` 方法始终使用 `action` 和 `controller` 的当前值，并生成路由到当前操作的 URL 路径。

### 按路由生成 URL

前面的代码演示了通过传入控制器和操作名称来生成 URL。 `IUrlHelper` 还提供 [Url.RouteUrl](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.iurlhelper.routeurl) 系列的方法。 这些方法类似于 [Url.Action](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.iurlhelper.action)，但它们不会将 `action` 和 `controller` 的当前值复制到路由值。 `Url.RouteUrl` 的最常见用法：

- 指定用于生成 URL 的路由名称。
- 通常不指定控制器或操作名称。

### 在 HTML 和 Razor 中生成 URL

[IHtmlHelper](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.rendering.ihtmlhelper) 提供 [HtmlHelper](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.viewfeatures.htmlhelper) 方法 [Html.BeginForm](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.rendering.ihtmlhelper.beginform) 和 [Html.ActionLink](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.rendering.ihtmlhelper.actionlink) 来分别生成 `<form>` 和 `<a>` 元素。 这些方法使用 [Url.Action](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.iurlhelper.action) 方法来生成 URL，并且采用相似的参数。 `HtmlHelper` 的配套 `Url.RouteUrl` 为 `Html.BeginRouteForm` 和 `Html.RouteLink`，两者具有相似的功能。

TagHelper 通过 `form` TagHelper 和 `<a>` TagHelper 生成 URL。 两者均通过 `IUrlHelper` 来实现。 有关详细信息，请参阅[表单中的标记助手](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/views/working-with-forms?view=aspnetcore-7.0)。

在视图内，可通过 `Url` 属性将 `IUrlHelper` 用于前文未涵盖的任何临时 URL 生成。

### 操作结果中的 URL 生成

前面的示例演示了如何在控制器中使用 `IUrlHelper`。 控制器中最常见的用法是在操作结果中生成 URL。

[ControllerBase](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.controllerbase) 和 [Controller](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.controller) 基类为操作结果提供简便的方法来引用另一项操作。 一种典型的用法是在接受用户输入后重定向：

```csharp
[HttpPost]
[ValidateAntiForgeryToken]
public IActionResult Edit(int id, Customer customer)
{
    if (ModelState.IsValid)
    {
        // Update DB with new details.
        ViewData["Message"] = $"Successful edit of customer {id}";
        return RedirectToAction("Index");
    }
    return View(customer);
}
```

[RedirectToAction](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.controllerbase.redirecttoaction) 和 [CreatedAtAction](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.controllerbase.createdataction) 等操作结果工厂方法遵循与 `IUrlHelper` 上的方法类似的模式。

## Areas

[区域](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/areas?view=aspnetcore-7.0)是一项 MVC 功能，用于将相关功能作为一个单独的组组织到一个组中：

- 控制器操作的路由命名空间。
- 视图的文件夹结构。

通过使用区域，应用可以有多个名称相同的控制器，只要它们具有不同的区域。 通过向 `controller` 和 `action` 添加另一个路由参数 `area`，可使用区域为路由创建层次结构。 本部分讨论路由如何与区域交互。 请参阅[区域](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/areas?view=aspnetcore-7.0)，详细了解如何将区域与视图一起使用。

下面的示例将 MVC 配置为对名为 `Blog` 的 `area` 使用默认传统路由和 `area` 路由：

```csharp
var builder = WebApplication.CreateBuilder(args);

builder.Services.AddControllersWithViews();

var app = builder.Build();

if (!app.Environment.IsDevelopment())
{    
    app.UseExceptionHandler("/Home/Error");
    app.UseHsts();
}

app.UseHttpsRedirection();
app.UseStaticFiles();

app.UseRouting();

app.UseAuthorization();

app.MapAreaControllerRoute("blog_route", "Blog",
        "Manage/{controller}/{action}/{id?}");
app.MapControllerRoute("default_route", "{controller}/{action}/{id?}");

app.Run();
```

在前面的代码中，调用 [MapAreaControllerRoute](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.builder.controllerendpointroutebuilderextensions.mapareacontrollerroute) 来创建 `"blog_route"`。 第二个参数 `"Blog"` 为区域名称。

匹配 `/Manage/Users/AddUser` 之类的 URL 路径时，`"blog_route"` 路由会生成路由值 `{ area = Blog, controller = Users, action = AddUser }`。 `area` 路由值由 `area` 的默认值生成。 `MapAreaControllerRoute` 创建的路由等价于以下内容：

```cs
app.MapControllerRoute("blog_route", "Manage/{controller}/{action}/{id?}",
        defaults: new { area = "Blog" }, constraints: new { area = "Blog" });
app.MapControllerRoute("default_route", "{controller}/{action}/{id?}");
```

`MapAreaControllerRoute` 通过为使用所提供的区域名称（本例中为 `Blog`）的 `area` 提供默认值和约束，来创建路由。 默认值确保路由始终生成 `{ area = Blog, ... }`，约束要求在生成 URL 时使用值 `{ area = Blog, ... }`。

传统路由依赖于顺序。 一般情况下，具有区域的路由应放在路由表中靠前的位置，因为它们比没有区域的路由更具体。

在前面的示例中，路由值 `{ area = Blog, controller = Users, action = AddUser }` 匹配以下操作：

```cs
using Microsoft.AspNetCore.Mvc;

namespace MyApp.Namespace1
{
    [Area("Blog")]
    public class UsersController : Controller
    {
        // GET /manage/users/adduser
        public IActionResult AddUser()
        {
            var area = ControllerContext.ActionDescriptor.RouteValues["area"];
            var actionName = ControllerContext.ActionDescriptor.ActionName;
            var controllerName = ControllerContext.ActionDescriptor.ControllerName;

            return Content($"area name:{area}" +
                $" controller:{controllerName}  action name: {actionName}");
        }        
    }
}
```

[[Area\]](https://learn.microsoft.com/zh-cn/dotnet/api/microsoft.aspnetcore.mvc.areaattribute) 属性将控制器表示为区域的一部分。 此控制器位于 `Blog` 区域。 没有`[Area]`属性的控制器不是任何区域的成员，并且当路由提供路由值时`area`**不匹配**。 在下面的示例中，只有所列出的第一个控制器才能与路由值 `{ area = Blog, controller = Users, action = AddUser }` 匹配。

```csharp
using Microsoft.AspNetCore.Mvc;

namespace MyApp.Namespace1
{
    [Area("Blog")]
    public class UsersController : Controller
    {
        // GET /manage/users/adduser
        public IActionResult AddUser()
        {
            var area = ControllerContext.ActionDescriptor.RouteValues["area"];
            var actionName = ControllerContext.ActionDescriptor.ActionName;
            var controllerName = ControllerContext.ActionDescriptor.ControllerName;

            return Content($"area name:{area}" +
                $" controller:{controllerName}  action name: {actionName}");
        }        
    }
}
```

```csharp
using Microsoft.AspNetCore.Mvc;

namespace MyApp.Namespace2
{
    // Matches { area = Zebra, controller = Users, action = AddUser }
    [Area("Zebra")]
    public class UsersController : Controller
    {
        // GET /zebra/users/adduser
        public IActionResult AddUser()
        {
            var area = ControllerContext.ActionDescriptor.RouteValues["area"];
            var actionName = ControllerContext.ActionDescriptor.ActionName;
            var controllerName = ControllerContext.ActionDescriptor.ControllerName;

            return Content($"area name:{area}" +
                $" controller:{controllerName}  action name: {actionName}");
        }        
    }
}
```

```csharp
using Microsoft.AspNetCore.Mvc;

namespace MyApp.Namespace3
{
    // Matches { area = string.Empty, controller = Users, action = AddUser }
    // Matches { area = null, controller = Users, action = AddUser }
    // Matches { controller = Users, action = AddUser }
    public class UsersController : Controller
    {
        // GET /users/adduser
        public IActionResult AddUser()
        {
            var area = ControllerContext.ActionDescriptor.RouteValues["area"];
            var actionName = ControllerContext.ActionDescriptor.ActionName;
            var controllerName = ControllerContext.ActionDescriptor.ControllerName;

            return Content($"area name:{area}" +
                $" controller:{controllerName}  action name: {actionName}");
        }
    }
}
```

为了完整起见，此处显示了每个控制器的命名空间。 如果前面的控制器使用相同的命名空间，则会生成编译器错误。 类命名空间对 MVC 的路由没有影响。

前两个控制器是区域成员，仅在 `area` 路由值提供其各自的区域名称时匹配。 第三个控制器不是任何区域的成员，只能在路由没有为 `area` 提供任何值时匹配。

就*不匹配任何值*而言，缺少 `area` 值相当于 `area` 的值为 NULL 或空字符串。

在某个区域内执行某项操作时，`area` 的路由值将以[环境值](https://learn.microsoft.com/zh-cn/aspnet/core/mvc/controllers/routing?view=aspnetcore-7.0#ambient)的形式提供，以便路由用于生成 URL。 这意味着默认情况下，区域在 URL 生成中具有*粘性*，如以下示例所示。

```csharp
app.MapAreaControllerRoute(name: "duck_route",
                                     areaName: "Duck",
                                     pattern: "Manage/{controller}/{action}/{id?}");
app.MapControllerRoute(name: "default",
                             pattern: "Manage/{controller=Home}/{action=Index}/{id?}");
```

```csharp
using Microsoft.AspNetCore.Mvc;

namespace MyApp.Namespace4
{
    [Area("Duck")]
    public class UsersController : Controller
    {
        // GET /Manage/users/GenerateURLInArea
        public IActionResult GenerateURLInArea()
        {
            // Uses the 'ambient' value of area.
            var url = Url.Action("Index", "Home");
            // Returns /Manage/Home/Index
            return Content(url);
        }

        // GET /Manage/users/GenerateURLOutsideOfArea
        public IActionResult GenerateURLOutsideOfArea()
        {
            // Uses the empty value for area.
            var url = Url.Action("Index", "Home", new { area = "" });
            // Returns /Manage
            return Content(url);
        }
    }
}
```

下面的代码生成 `/Zebra/Users/AddUser` 的 URL：

```csharp
public class HomeController : Controller
{
    public IActionResult About()
    {
        var url = Url.Action("AddUser", "Users", new { Area = "Zebra" });
        return Content($"URL: {url}");
    }
```

## 操作定义

控制器上的公共方法（除了那些带有 属性的方法）均为操作。

## 代码示例

- [MyDisplayRouteInfo](https://github.com/Rick-Anderson/RouteInfo/blob/master/Microsoft.Docs.Samples.RouteInfo/ControllerContextExtensions.cs) 由 [Rick.Docs.Samples.RouteInfo](https://www.nuget.org/packages/Rick.Docs.Samples.RouteInfo) NuGet 包提供，会显示路由信息。
- [查看或下载示例代码](https://github.com/dotnet/AspNetCore.Docs/tree/main/aspnetcore/mvc/controllers/routing/samples/3.x)（[如何下载](https://learn.microsoft.com/zh-cn/aspnet/core/introduction-to-aspnet-core?view=aspnetcore-7.0#how-to-download-a-sample)）

## 调试诊断

要获取详细的路由诊断输出，请将 `Logging:LogLevel:Microsoft` 设置为 `Debug`。 在开发环境中，在 `appsettings.Development.json` 中设置日志级别：

```json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Debug",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  }
```