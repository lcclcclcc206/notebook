## 配置 package.json

package.json 文件是 Node.js 项目的清单文件。 它包含有关项目的元数据信息。 它还控制诸如如何管理依赖项，以及将哪些文件放入用于 npm 的包中等事项。 接下来让我们更深入地了解属性及其含义。

package.json 文件不是你手动创作的内容， 这是运行 npm `init` 命令的结果。 可以通过两种主要方法运行此命令：

- `npm init`：此命令启动一个向导，该向导将提示你提供有关项目的名称、版本、说明、入口点、测试命令、Git 存储库、关键字、作者和许可证的信息。
- `npm init -y`：此命令使用 `-y` 标志，是 `npm init` 命令的更快版本，因为它不需要交互。 相反，此命令会使用 `npm init` 自动为系统提示你输入的所有值分配默认值。

`npm init` 和 `npm init -y` 命令都将生成 package.json 文件。 下面是一个示例：

```json
{
  "name": "my project",
  "version": "1.0.0",
  "description": "",
  "main": "script.js",
  "dependencies": {},
  "devDependencies": {},
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC"
}
```

你可以将 package.json 文件中所有可能的属性视为属于以下组：

- **元信息**：此组中的属性定义了有关项目的元信息。 属性包括项目名称、说明、作者、关键字等。
- **依赖项**：有 `dependencies` 和 `devDependencies` 这两个属性，用于说明所使用的库。 在本模块的稍后部分，你将了解如何使用这些属性来安装、更新和分离依赖项。
- **脚本**：在本部分，可以列出项目任务的脚本，例如开始、生成、测试和 lint。

### 用于管理项目的脚本

你可能需要有一种方法来运行、测试和生成任何项目，而无论它是否使用 Node.js。 Node.js 运行时可识别此需求，并提供有关如何命名脚本的指导。 其思路是确保所有 Node.js 项目都使用一致的脚本名称。 如果你可以在 Node.js 项目之间移动，并可通过一组一致的操作快速确定自己的方向，则可以获得更好的开发人员体验。 用于 DevOps 和检测的各种工具可以利用此命名一致性。

你应该设置四个脚本，并以特定方式对其命名。 开发人员社区和各种工具期望以下特定名称：

- `start`：使用条目文件作为参数调用 `node`。 示例：`node ./src/index.js`。 此操作调用 `node` 命令并使用条目文件 `index.js`。
- `build`：说明如何生成项目。 生成过程应生成一些可交付的内容。 例如，build 命令可以运行 TypeScript 编译器以生成要交付的项目的 JavaScript 版本。
- `test`：运行项目的测试。 如果使用第三方测试库，则该命令应调用库的可执行文件。
- `lint`：调用类似 ESLint 的 Linter 程序。 Lint 分析可查找代码中不一致的内容。 Linter 通常还提供一种方法来更正不一致。 具有一致的代码可以极大地提高其可读性，进而加速功能的开发和代码的添加。

那么实际上如何对它们命名呢？

首先看一下常规语法。 然后，我们将介绍应如何命名脚本。

`scripts` 部分的语法通常如下所示：

```json
"scripts" : {
  "<action>" : "<command>"
}
```

下面是一个更现实的示例：

```json
"scripts" : {
  "start" : "node ./dist/index.js",
  "test": "jest",
  "build": "tsc",
  "lint": "eslint"
}
```

此示例使用我们之前查看的命名。 首先执行用于启动应用程序的 `start` 操作。 接下来，`test` 操作使用 `jest` 测试框架运行测试。 然后，你就有了使用 TypeScript 编译器 `tsc` 的 `build` 操作。 此命令将 TypeScript 中的代码编译成浏览器可以解释的形式，例如 ES6。 最后，你可以使用 `eslint` Lint 分析工具来查找代码中的不一致和可能的错误。

你可以通过输入命令 `npm run <action>` 来调用操作。 例如 `npm run lint`。

`start` 和 `test` 操作特殊在于你可以在命令中省略单词 `run`。 你可以输入 `npm start`，而不是输入命令 `npm run start`。

这四个操作对于任何 Node.js 项目都是一个很好的起点，但每个项目可能会有更多特定于项目本身的脚本。

## 在项目中添加包

Node.js 附带许多核心库，可处理从文件管理到 HTTP 再到压缩文件等各种任务。 但是，还存在巨大的第三方库生态系统。 得益于 npm（节点包管理器），你可以轻松地安装这些库并在应用程序中使用它们。

在安装软件包之前，可以转到 `https://www.npmjs.com/package/<package name>` 了解有关软件包的更多信息。 此 URL 显示包的详细信息页面。 选择“依赖项”选项卡，查看有多少包以及这些包依赖哪些包来运行。 获得类似结果的另一种方法是运行此 npm 命令：`npm view <package name>`。

对于列出的依赖项，包的数量可能并不能说明全部事实。 如果下载一个包，你可能会得到一个包含上千个包的 node_modules 文件夹。 为什么会这样？ 每个包都有一系列依赖项。 为了确保可以使用包，运行 `npm install <package name>` 命令时将抓取和下载所有依赖项。

使用名为 `npm` 的内置命令行工具来安装包。 可通过在终端中调用命令，将包添加到 Node.js 项目。

典型的安装命令如下所示：`npm install <name of package>`。

在运行 `install` 命令时，命令行工具连接到全局注册表并提取代码，将其放在项目的 node_modules 文件中。 安装之后，项目目录将如下所示：

```output
-| node_modules/
---| <name of dependency>/
------| <files included in the dependency>
```

## 查找包

运行 `npm install <name of dependency>` 时，Node.js 会转到称为 npm 注册表的全局注册表，并查找要下载的代码。 它位于 `http://npmjs.org`。 在浏览器中，还可以查看包的此页面。 该站点保存包：源代码的压缩版本。 每个包都有可以访问的专用网站。 可在这些网站上详细了解源代码所在的位置，并查找其他信息，例如有关下载的指标和有关维护的信息。

## 生产依赖项与开发依赖项

依赖项属于以下两个类别之一：

- **生产依赖项**：生产依赖项是应用程序投入生产时需要运行的依赖项。 必须在应用程序中内置生产依赖项，以便在应用程序运行时该功能可用。 示例包括一个可用于生成 Web 应用程序的 Web 框架。
- **开发依赖项**：开发依赖项是仅在开发应用程序时需要的依赖项。 可将这些依赖项视为修建建筑物时使用的脚手架。 完成修建后，你便不再需要它们了。 这些依赖项的示例包括测试库、Lint 分析工具或捆绑工具。 这些依赖项是确保应用程序正常运行的重要部分，但你不需要随应用程序一起提供。

这种分离不仅是概念上的。 当你下载依赖项时，npm 工具会将条目添加到清单文件中以此来写入。 借助此工具，可通过将标志添加到安装命令来区分这两种类型的依赖项。 此标志将依赖项的名称及其版本放置在一个名为 `dependencies` 或 `devDependencies` 的部分。 这种区别可清楚地分离应用程序中的依赖项及其类型。 无论安装哪种类型的依赖项，它都存储在 node_modules 目录中。 该标志仅影响清单文件。

这种分离不同类型依赖项的方式还会内置于 npm 命令行工具中。 如果在安装依赖项时指定了 `--production` 标志，则只会安装生产 `dependencies`。 例如，持续集成和持续部署 (CI/CD) 管道使用此标志来确保仅安装运行应用所需的依赖项。

## 如何安装包？

运行 `npm install <dependency name>` 命令以安装要用作应用程序一部分的正常依赖项。 开发人员依赖项是指不会交付到生产环境中的内容。 要安装开发人员依赖项，请添加 `--save-dev` 标志。

还有一些可全局安装的包。 这些包通常不会导入到项目中。 因此，许多全局包都是 CLI 工具。 其中一些包允许自己导入，例如 `http-server`。

如果全局安装某些包，则其不会安装在项目的 node_modules 文件夹中。 而是安装在特定于计算机的目录中，因此可用于计算机上的所有 Node.js 项目。 要安装全局包，请将 `-g` 标志添加到 `install command`，因此该命令类似于 `npm install <dependency name> -g`。

但是，创建 npx 工具在某种程度上是为了解决以下问题：随着时间的推移，全局安装了多个依赖项后，会占用大量空间。 此外，在许多操作系统上，全局安装的工具需要更高的权限才能安装。 主要的一点是，全局依赖项用于完成极有可能很少需要执行的任务。 因此，几乎只要在临时有需要时在计算机上安装这些工具即可。

npx 工具可用于将依赖项加载到 Node.js 进程，并从该处运行命令。 运行命令后，将清理系统中的依赖项并将其删除。 自 5.2 版起，npm 的所有主版本中均附带 npx 工具。 此工具是使用很少运行的依赖项的首选方法。 要使用 npx 工具，请输入 `npx <name of package>`。 它将提取依赖项、运行命令并进行清理。

## 清理依赖项

你很可能迟早会意识到不再需要某个包。 或者，你可能意识到安装的包不是你需要的。 也许你已经找到了一个可更好地完成任务的包。 无论出于什么原因，都应删除不使用的依赖项。 这样可保持整洁。 此外，依赖项还会占用空间。

如果要使用 Angular、React 或 Vue 等框架生成 SPA 应用程序，空间问题就变得更加重要。 这些应用程序也是 Node.js 项目。 生成这些应用程序涉及“绑定”和“缩小”过程，该过程中的不同 Node.js 模块连接在一起，并且源代码经过了压缩。 生成的捆绑最终由浏览器提供。 捆绑越大，在成为客户可与之交互的内容之前，通过网络发送的时间就越长。 客户需要等待的时间越长，就越有可能避开你的应用。

可以通过两种方法清理不再需要的依赖项：

- **卸载**：要卸载包，请运行 `npm uninstall <name of dependency>`。 此命令不仅将从清单文件中删除包，还会从 node_modules 文件夹中删除包。
- **删除**：还可以运行 `npm prune` 命令。 通过运行此命令，可删除 node_modules 文件夹中未在清单文件中作为依赖项列出的所有依赖项。 如果要删除多个依赖项，并且不想为每个依赖项运行 `uninstall` 命令，则此命令是一个不错的选择。 要使用此命令删除未使用的依赖项，请先从清单文件的 `dependencies` 或 `devDependencies` 部分删除条目，然后运行 `npm prune` 命令。

## 使用 npm 更新包

可通过两种方式来安装包。 可以运行 `install` 命令或 `update` 命令。 这两个命令之间曾经存在差异。 但现在这两个命令更像是彼此的别名。 用于更新包的典型命令可能为：`npm update <name of package>@<optional argument with version number>`。

更新过程的具体操作取决于两个条件：

- **是否在命令中指定了版本参数**。 如果在 `npm update` 命令中指定了版本参数（最后一个参数），则将提取和安装指定包版本。
- **清单文件中的条目**。 清单文件中的条目包括依赖项的名称，以及表示如何更新依赖项的规则模式的值。 下面是一个示例：`"<name of dependency>": "1.1.x"`。 npm 工具将遵循规则模式，并尝试提取与规则模式匹配的依赖项版本。

在更新一个或多个依赖项之前，应配置清单文件，以便在运行 `npm update <name of dependency>` 命令时获得可预测的行为。 你可传达要对包采取的方法。 Node.js 包含一组符号，允许你定义包的更新方式。

此过程是向 package.json 文件中的包条目添加不同的前缀。 除了主版本/次要版本/修补程序版本以外，还有很多内容可以配置。 还可以表示你仅需要特定范围内的包，或者需要具有特定标记（如 `alpha` 或 `beta`）的包。

下面是可为主版本/次要版本/修补程序版本配置的一些模式：

| 模式                 | 更新级别                 |
| :------------------- | :----------------------- |
| x.0.0 或 *（星号）   | 更新到最高主版本。       |
| 1.x.1 或 ^（插入符） | 仅更新到次要版本。       |
| 1.1.x 或 ~（波浪号） | 更新到最新修补程序版本。 |

可以使用“~1.0.0”模式，以仅更新修补程序版本。 使用此模式会更新到“同一范围内的同等版本或更高版本”。

### package-lock.json

将此文件提交到存储库的一个原因是它可以保证完全安装。 请记住如何在 package.json 中为需要的安装类型（例如修补程序、次要版本或主版本）定义模式。 模式并不准确。 如果使用 `1.x` 模式，则不知道安装的是版本 1.4 还是 1.5。

你可能需要知道安装的是哪个版本。 请考虑指定模式 `1.x` 的情况，即在代码中专门使用版本 1.2，然后发布版本 1.4。 新版本最终中断了你的代码。 安装应用的人员因而将得到一个无法运行的应用。 但是，如果有一个 package-lock.json 文件表明使用版本 1.2，则将安装版本 1.2。 那么，谁会关心此行为呢？ 使用你的应用和持续集成 (CI) 工具的人。

了解此过程以及哪个文件确定何时进行安装很重要。 其工作方式如下所述：

- 如果 package.json 和 package-lock.json 文件就语义规则级别达成一致，则不会发生冲突。 例如，如果模式在 package.json 文件中指明 `1.x`，而 package-lock.json 文件指定安装版本 1.4，则将安装版本 1.4。
- 如果 package.json 文件指定了类似 `1.8.x` 的模式，则不会实现 package-lock.json 文件中的说明。 将安装次要版本 1.8.0 或更高版本，或更高修补程序版本（如果有）。

package-lock.json 文件还提供其他功能。 它便于查看提交之间的更改，并有助于优化安装过程。

当你执行一些修改 node_modules 目录的操作，或执行更改 package-lock.json 文件中的依赖项的任何操作时，将生成此文件。 运行 `npm init` 命令时不会创建此文件。 例如，安装包时会创建该文件。

应将 package-lock.json 文件提交到存储库。

## 查找和更新过时的包

`npm outdated` 命令列出了已过时的包。 此命令可帮助识别何时有更新版本的包可用。 以下是命令的典型输出：

```output
Package       Current    Wanted   Latest     Location     Depended by
lodash        1.0.0      1.0.0    4.17.19    lock-test    main-code-file
node-fetch    1.2.0      1.2.0    2.6.0      lock-test    function-code-file
```

输出中的列包括：

- 包：已过时的包。
- 当前版本：当前安装的包版本。
- 所需版本：与在 package.json 文件中指定的语义模式匹配的最新版本。
- 最新版本：包的最新版本。
- 位置：包依赖项的位置。 `outdated` 命令会遍历各 node_modules 文件夹中的所有已安装的包。
- 依赖方：具有依赖项的包。

建议的工作流是按以下顺序运行这些命令：

1. 运行 `npm outdated` 命令以列出所有已过时的包。 此命令提供“所需版本”、“最新版本”和“位置”列中的信息。
2. 运行 `npm update <optional package name>` 命令以更新已安装的包。 如果使用指定的包名称运行此命令，则该命令会尝试仅更新指定的包。 如果未指定包，则该命令会尝试更新 package.json 中的所有包。

## 管理安全问题

每次更新或安装包时，都会在安装完成后获得日志响应。 该响应将告诉你所安装的版本，以及是否有任何漏洞。 日志将类似于以下示例：

```output
+ lodash@1.3.1
added 1 package from 4 contributors and audited 1 package in 0.949s
found 3 vulnerabilities (1 low, 2 high)
  run `npm audit fix` to fix them, or `npm audit` for details
```

该日志列出了高严重性级别和低严重性级别的漏洞。 如果有任何高级别漏洞，应该更新包。 要修复问题并应用更新，可以按日志响应所示运行 `npm audit` 命令。 此命令会列出每个漏洞。 `npm audit` 中的响应将类似于以下示例：

```output
# Run  npm install lodash@4.17.15  to resolve 3 vulnerabilities

| Low            | Prototype Pollution               |
|----------------|-----------------------------------|
| Package        | lodash                            |
| Dependency of  | lodash                            |
| Path           | lodash                            |
| More info      | https://npmjs.com/advisories/577  |  

and so on..
```

`npm audit fix` 命令尝试修复此问题。 它尝试升级到不存在此问题的次要版本。 该操作可能还不够。 系统可能会提示你运行 `npm audit fix --force` 命令来修复问题。 此操作涉及中断性更改。 即包的主版本将更新。

漏洞是代码中的弱点，攻击者可以利用它执行恶意操作。 攻击者可以利用这些弱点获取对你的数据和系统的访问权限。 你应慎重对待漏洞。

总是会发现漏洞。 它们非常常见，GitHub 已实现了一个函数，用于扫描存储库并自动创建 PR，在发现漏洞时建议你升级到更安全的版本。 你应偶尔运行审核命令 `npm audit`。 安全工作，人人有责。 GitHub 等大型存储库提供程序会尽他们的责任。 如果发现任何漏洞，你可以通过审核并修复漏洞来尽自己的职责。